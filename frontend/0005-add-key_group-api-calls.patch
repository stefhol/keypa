From cddb450f083cd8b563763c9e9df356ec4d37c955 Mon Sep 17 00:00:00 2001
From: stefhol <hoef.stef@pm.me>
Date: Sun, 6 Nov 2022 23:20:02 +0100
Subject: [PATCH 05/11] add key_group api calls

---
 .vscode/launch.json                    |   2 +-
 api/src/api/key.rs                     |  30 ++++
 api/src/api/key_group.rs               | 208 +++++++++++++++++++++++++
 api/src/api/mod.rs                     |   1 +
 api/src/api/worker.rs                  |   4 +-
 api/src/crud/building.rs               |  33 ++++
 api/src/crud/door.rs                   |  77 +++++++++
 api/src/crud/key.rs                    | 104 +++++++++++++
 api/src/crud/key_group.rs              | 128 +++++++++++++++
 api/src/crud/mod.rs                    |   5 +
 api/src/crud/room.rs                   |  42 +++++
 api/src/main.rs                        |  31 +++-
 entities/src/model/tbl_door.rs         |   2 +-
 entities/src/model/tbl_key_group.rs    |  23 ++-
 entities/src/model/tbl_user.rs         |  16 +-
 migrations/20221020190412_setup.up.sql |   4 +-
 mock/src/main.rs                       |  30 ++--
 17 files changed, 709 insertions(+), 31 deletions(-)
 create mode 100644 api/src/api/key_group.rs
 create mode 100644 api/src/crud/building.rs
 create mode 100644 api/src/crud/door.rs
 create mode 100644 api/src/crud/key.rs
 create mode 100644 api/src/crud/key_group.rs
 create mode 100644 api/src/crud/room.rs

diff --git a/.vscode/launch.json b/.vscode/launch.json
index 8f4a3e6..1a57cc0 100644
--- a/.vscode/launch.json
+++ b/.vscode/launch.json
@@ -12,7 +12,7 @@
                 "args": [
                     "build",
                     "--bin",
-                    "mock"
+                    "api"
                 ]
             },
             "args": []
diff --git a/api/src/api/key.rs b/api/src/api/key.rs
index 8b13789..6c4067a 100644
--- a/api/src/api/key.rs
+++ b/api/src/api/key.rs
@@ -1 +1,31 @@
+use actix_web::{get, web::Data, HttpResponse};
+use sea_orm::DatabaseConnection;
 
+use crate::{
+    crud,
+    util::{
+        error::CrudError,
+        middleware::{extractor::Authenticated, SecurityLevel},
+    },
+};
+#[utoipa::path(
+    context_path = "/api/v1",
+    responses(
+    (status = 200, body=[Vec<GetKey>]),
+    (status = 400),
+    (status = 401),
+    (status = 404),
+    (status = 406),
+    (status = 500),
+)
+)]
+#[get("/self/keys")]
+pub async fn get_self_key(
+    db: Data<DatabaseConnection>,
+    auth: Authenticated,
+) -> actix_web::Result<HttpResponse, CrudError> {
+    auth.has_high_enough_security_level(SecurityLevel::User)?;
+    let user_id = &auth.try_get_user_id()?;
+    let keys = crud::key::get_keys_of_user_id(user_id, db.get_ref()).await?;
+    Ok(HttpResponse::Ok().json(keys))
+}
diff --git a/api/src/api/key_group.rs b/api/src/api/key_group.rs
new file mode 100644
index 0000000..ee2d8d2
--- /dev/null
+++ b/api/src/api/key_group.rs
@@ -0,0 +1,208 @@
+use actix_web::{
+    delete, get, post, put,
+    web::{Data, Json, Path, Query},
+    HttpResponse,
+};
+use sea_orm::DatabaseConnection;
+use serde::Deserialize;
+use utoipa::IntoParams;
+use uuid::Uuid;
+
+use crate::{
+    crud::{self, key_group::CreateKeyGroup},
+    util::{
+        error::CrudError,
+        middleware::{extractor::Authenticated, SecurityLevel},
+    },
+};
+#[derive(Debug, Deserialize, IntoParams)]
+pub struct UserQuery {
+    user_id: Option<Uuid>,
+}
+#[utoipa::path(
+    params(UserQuery),
+    context_path = "/api/v1",
+    responses(
+    (status = 200),
+    (status = 400),
+    (status = 401),
+    (status = 404),
+    (status = 406),
+    (status = 500),
+)
+)]
+#[get("/key-group")]
+pub async fn get_key_group(
+    db: Data<DatabaseConnection>,
+    user_query: Query<UserQuery>,
+    auth: Authenticated,
+) -> actix_web::Result<HttpResponse, CrudError> {
+    auth.has_high_enough_security_level(SecurityLevel::User)?;
+    let key_groups = match user_query.user_id {
+        Some(user_id) => crud::key_group::get_key_group_of_user(&db, &user_id).await?,
+        None => crud::key_group::get_all_key_group(&db).await?,
+    };
+
+    Ok(HttpResponse::Ok().json(key_groups))
+}
+
+#[derive(Debug, Deserialize, IntoParams)]
+pub struct KeyGroupQuery {
+    key_id: Uuid,
+}
+#[utoipa::path(
+    params(KeyGroupQuery),
+    context_path = "/api/v1",
+    responses(
+    (status = 200),
+    (status = 400),
+    (status = 401),
+    (status = 404),
+    (status = 406),
+    (status = 500),
+)
+)]
+#[put("/key-group/{key_group_id}")]
+pub async fn add_key_into_key_group(
+    key_group_id: Path<Uuid>,
+    query: Query<KeyGroupQuery>,
+    db: Data<DatabaseConnection>,
+    auth: Authenticated,
+) -> actix_web::Result<HttpResponse, CrudError> {
+    auth.has_high_enough_security_level(SecurityLevel::Worker)?;
+    crud::key_group::add_key_to_key_group(&query.key_id, &key_group_id, &db).await?;
+    Ok(HttpResponse::Ok().finish())
+}
+#[utoipa::path(
+    params(KeyGroupQuery),
+    context_path = "/api/v1",
+    responses(
+    (status = 200),
+    (status = 400),
+    (status = 401),
+    (status = 404),
+    (status = 406),
+    (status = 500),
+)
+)]
+#[delete("/key-group/{key_group_id}")]
+pub async fn delete_key_from_key_group(
+    key_group_id: Path<Uuid>,
+    query: Query<KeyGroupQuery>,
+    db: Data<DatabaseConnection>,
+    auth: Authenticated,
+) -> actix_web::Result<HttpResponse, CrudError> {
+    is_self_or_security_level(SecurityLevel::Worker, &auth, &key_group_id, &db).await?;
+
+    crud::key_group::remove_key_from_key_group(&query.key_id, &key_group_id, &db).await?;
+    Ok(HttpResponse::Ok().finish())
+}
+#[utoipa::path(
+    context_path = "/api/v1",
+    responses(
+    (status = 200, body = [Vec<GetKey>]),
+    (status = 400),
+    (status = 401),
+    (status = 404),
+    (status = 406),
+    (status = 500),
+)
+)]
+#[get("/key-group/{key_group_id}")]
+pub async fn get_keys_of_key_group(
+    key_group_id: Path<Uuid>,
+    db: Data<DatabaseConnection>,
+    auth: Authenticated,
+) -> actix_web::Result<HttpResponse, CrudError> {
+    is_self_or_security_level(SecurityLevel::Worker, &auth, &key_group_id, &db).await?;
+
+    let keys = crud::key_group::get_keys_of_key_group(&db, &key_group_id).await?;
+    Ok(HttpResponse::Ok().json(keys))
+}
+#[utoipa::path(
+    context_path = "/api/v1",
+    responses(
+    (status = 200, body = [Vec<GetKeyGroup>]),
+    (status = 400),
+    (status = 401),
+    (status = 404),
+    (status = 406),
+    (status = 500),
+)
+)]
+#[get("/key-group/self")]
+pub async fn get_self_key_group(
+    db: Data<DatabaseConnection>,
+    auth: Authenticated,
+) -> actix_web::Result<HttpResponse, CrudError> {
+    auth.has_high_enough_security_level(SecurityLevel::User)?;
+    let user_id = auth.try_get_user_id()?;
+    let key_groups = crud::key_group::get_key_group_of_user(&db, &user_id).await?;
+    Ok(HttpResponse::Ok().json(key_groups))
+}
+#[utoipa::path(
+    context_path = "/api/v1",
+    responses(
+    (status = 200, body = [GetKeyGroup]),
+    (status = 400),
+    (status = 401),
+    (status = 404),
+    (status = 406),
+    (status = 500),
+)
+)]
+#[post("/key-group")]
+pub async fn add_key_group(
+    db: Data<DatabaseConnection>,
+    key_group: Json<CreateKeyGroup>,
+    auth: Authenticated,
+) -> actix_web::Result<HttpResponse, CrudError> {
+    auth.has_high_enough_security_level(SecurityLevel::User)?;
+    let key_groups = crud::key_group::create_key_group(&key_group, &db).await?;
+    Ok(HttpResponse::Ok().json(key_groups))
+}
+#[utoipa::path(
+    context_path = "/api/v1",
+    responses(
+    (status = 200, body = [GetKeyGroup]),
+    (status = 400),
+    (status = 401),
+    (status = 404),
+    (status = 406),
+    (status = 500),
+)
+)]
+#[put("/key-group/{key_group_id}")]
+pub async fn upate_key_group(
+    db: Data<DatabaseConnection>,
+    key_group_id: Path<Uuid>,
+    key_group: Json<CreateKeyGroup>,
+    auth: Authenticated,
+) -> actix_web::Result<HttpResponse, CrudError> {
+    is_self_or_security_level(SecurityLevel::Worker, &auth, &key_group_id, &db).await?;
+
+    let key_groups = crud::key_group::update_key_group(&key_group, &key_group_id, &db).await?;
+    Ok(HttpResponse::Ok().json(key_groups))
+}
+///Check if security_level is high enough or query database to check if it is the object of a user
+async fn is_self_or_security_level(
+    security_level: SecurityLevel,
+    auth: &Authenticated,
+    key_group_id: &Uuid,
+    db: &DatabaseConnection,
+) -> Result<(), CrudError> {
+    match auth.has_high_enough_security_level(security_level) {
+        Ok(_) => {}
+        Err(_) => {
+            let user_id = auth.try_get_user_id()?;
+            if !crud::key_group::get_key_group_of_user(&db, &user_id)
+                .await?
+                .iter()
+                .any(|f| key_group_id.to_string() == f.key_group_id.to_string())
+            {
+                return Err(CrudError::Unauthorized);
+            }
+        }
+    }
+    Ok(())
+}
diff --git a/api/src/api/mod.rs b/api/src/api/mod.rs
index 71489ea..390aef2 100644
--- a/api/src/api/mod.rs
+++ b/api/src/api/mod.rs
@@ -1,4 +1,5 @@
 pub mod auth;
 pub mod key;
+pub mod key_group;
 pub mod user;
 pub mod worker;
diff --git a/api/src/api/worker.rs b/api/src/api/worker.rs
index 8f016a4..10b2908 100644
--- a/api/src/api/worker.rs
+++ b/api/src/api/worker.rs
@@ -122,11 +122,11 @@ pub async fn get_worker(
 )
 )]
 #[get("/self/worker")]
-pub async fn get_self(
+pub async fn get_self_worker(
     db: Data<DatabaseConnection>,
     auth: Authenticated,
 ) -> actix_web::Result<HttpResponse, CrudError> {
-    auth.has_high_enough_security_level(SecurityLevel::Leader)?;
+    auth.has_high_enough_security_level(SecurityLevel::Worker)?;
     let user_id = auth.try_get_user_id()?;
     let worker = crud::worker::get_worker_by_user_id(db.get_ref(), &user_id).await?;
     Ok(HttpResponse::Ok().json(worker))    
diff --git a/api/src/crud/building.rs b/api/src/crud/building.rs
new file mode 100644
index 0000000..1919b5f
--- /dev/null
+++ b/api/src/crud/building.rs
@@ -0,0 +1,33 @@
+use entities::model::tbl_building;
+use sea_orm::{DatabaseConnection, EntityTrait};
+use serde::{Deserialize, Serialize};
+use utoipa::ToSchema;
+use uuid::Uuid;
+
+use crate::util::error::CrudError;
+#[derive(Debug, Serialize, Deserialize, ToSchema)]
+pub struct GetBuilding {
+    pub building_id: Uuid,
+    pub name: String,
+}
+impl From<&tbl_building::Model> for GetBuilding {
+    fn from(building: &tbl_building::Model) -> Self {
+        let building = building.clone();
+        Self {
+            building_id: building.building_id,
+            name: building.name,
+        }
+    }
+}
+pub async fn get_door_from_room_id(
+    building_id: &Uuid,
+    db: &DatabaseConnection,
+) -> Result<GetBuilding, CrudError> {
+    let model = tbl_building::Entity::find_by_id(building_id.clone())
+        .one(db)
+        .await?;
+    match model {
+        Some(model) => Ok((&model).into()),
+        None => Err(CrudError::NotFound),
+    }
+}
diff --git a/api/src/crud/door.rs b/api/src/crud/door.rs
new file mode 100644
index 0000000..3a83952
--- /dev/null
+++ b/api/src/crud/door.rs
@@ -0,0 +1,77 @@
+use entities::model::{tbl_door, tbl_room};
+use sea_orm::{DatabaseConnection, EntityTrait};
+use serde::{Deserialize, Serialize};
+use utoipa::ToSchema;
+use uuid::Uuid;
+
+use crate::util::error::CrudError;
+
+use super::{building::GetBuilding, room::GetRoom};
+#[derive(Debug, Serialize, Deserialize, ToSchema)]
+pub struct GetDoorWithRoom {
+    pub door_id: Uuid,
+    pub name: String,
+    pub room_id: Uuid,
+    pub room_name: String,
+    pub floor: i32,
+    pub is_sensitive: Option<bool>,
+    pub building_id: Uuid,
+    pub building: Option<GetBuilding>,
+}
+impl From<&(tbl_door::Model, Option<tbl_room::Model>)> for GetDoorWithRoom {
+    fn from((door, room): &(tbl_door::Model, Option<tbl_room::Model>)) -> Self {
+        let room = room.clone().expect("Can not be null");
+        Self {
+            door_id: door.door_id,
+            name: door.name.clone(),
+            room_id: room.room_id,
+            room_name: room.name,
+            floor: room.floor,
+            building: None,
+            is_sensitive: room.is_sensitive,
+            building_id: room.building_id,
+        }
+    }
+}
+#[derive(Debug, Serialize, Deserialize, ToSchema)]
+pub struct GetDoor {
+    pub door_id: Uuid,
+    pub name: String,
+    pub room_id: Uuid,
+    pub room: Option<GetRoom>,
+}
+impl From<&tbl_door::Model> for GetDoor {
+    fn from(door: &tbl_door::Model) -> Self {
+        Self {
+            door_id: door.door_id,
+            name: door.name.clone(),
+            room_id: door.room_id,
+            room: None,
+        }
+    }
+}
+pub async fn get_door_and_room_from_door_id(
+    door_id: &Uuid,
+    db: &DatabaseConnection,
+) -> Result<GetDoorWithRoom, CrudError> {
+    let model = tbl_door::Entity::find_by_id(door_id.clone())
+        .find_also_related(tbl_room::Entity)
+        .one(db)
+        .await?;
+    match model {
+        Some(model) => Ok((&model).into()),
+        None => Err(CrudError::NotFound),
+    }
+}
+pub async fn get_door_from_door_id(
+    door_id: &Uuid,
+    db: &DatabaseConnection,
+) -> Result<GetDoor, CrudError> {
+    let model = tbl_door::Entity::find_by_id(door_id.clone())
+        .one(db)
+        .await?;
+    match model {
+        Some(model) => Ok((&model).into()),
+        None => Err(CrudError::NotFound),
+    }
+}
diff --git a/api/src/crud/key.rs b/api/src/crud/key.rs
new file mode 100644
index 0000000..a23a7f1
--- /dev/null
+++ b/api/src/crud/key.rs
@@ -0,0 +1,104 @@
+use chrono::{DateTime, Utc};
+use entities::model::{tbl_key, tbl_key_user_history};
+use sea_orm::{
+    prelude::DateTimeUtc, ColumnTrait, DatabaseConnection, DbBackend, EntityTrait, QueryFilter,
+    Statement,
+};
+use serde::{Deserialize, Serialize};
+use utoipa::ToSchema;
+use uuid::Uuid;
+
+use crate::util::error::CrudError;
+
+use super::{door::GetDoor, user::GetUser};
+#[derive(Debug, Serialize, Deserialize, ToSchema)]
+pub struct GetKey {
+    pub key_id: Uuid,
+    pub name: String,
+    pub value: String,
+    pub description: Option<String>,
+    pub door_id: Uuid,
+    pub door: Option<GetDoor>,
+}
+impl From<&tbl_key::Model> for GetKey {
+    fn from(key: &tbl_key::Model) -> Self {
+        let key = key.clone();
+        Self {
+            key_id: key.key_id,
+            name: key.name,
+            value: key.value,
+            description: key.description,
+            door_id: key.door_id,
+            door: None,
+        }
+    }
+}
+#[derive(Debug, Serialize, Deserialize, ToSchema)]
+pub struct GetKeyHistory {
+    pub key_id: Uuid,
+    pub key: Option<GetKey>,
+    pub user_id: Uuid,
+    pub user: Option<GetUser>,
+    pub due_at: Option<DateTimeUtc>,
+    pub lent_at: Option<DateTimeUtc>,
+    pub lent: Option<bool>,
+    pub is_active: Option<bool>,
+    pub has_problem: Option<bool>,
+    pub comment: Option<String>,
+}
+impl From<&tbl_key_user_history::Model> for GetKeyHistory {
+    fn from(key_history: &tbl_key_user_history::Model) -> Self {
+        Self {
+            key_id: key_history.key_id,
+            key: None,
+            user_id: key_history.user_id,
+            user: None,
+            due_at: key_history.lent_at.map(|f| DateTime::from_local(f, Utc)),
+            lent_at: key_history.lent_at.map(|f| DateTime::from_local(f, Utc)),
+            lent: key_history.lent,
+            is_active: key_history.is_active,
+            has_problem: key_history.has_problem,
+            comment: key_history.comment.clone(),
+        }
+    }
+}
+pub async fn get_key_history_by_user_id(
+    user_id: &Uuid,
+    db: &DatabaseConnection,
+) -> Result<Vec<GetKeyHistory>, CrudError> {
+    let key = tbl_key_user_history::Entity::find()
+        .filter(tbl_key_user_history::Column::UserId.eq(user_id.clone()))
+        .all(db)
+        .await?;
+
+    Ok(key.iter().map(|f| f.into()).collect())
+}
+pub async fn get_key_by_key_id(
+    key_id: &Uuid,
+    db: &DatabaseConnection,
+) -> Result<GetKey, CrudError> {
+    let key = tbl_key::Entity::find_by_id(key_id.clone()).one(db).await?;
+
+    match key {
+        Some(key) => Ok((&key).into()),
+        None => Err(CrudError::NotFound),
+    }
+}
+pub async fn get_keys_of_user_id(
+    user_id: &Uuid,
+    db: &DatabaseConnection,
+) -> Result<Vec<GetKey>, CrudError> {
+    let values = tbl_key::Entity::find()
+        .from_raw_sql(Statement::from_sql_and_values(
+            DbBackend::Postgres,
+            r#"select (tbl_key.*) from tbl_user
+            join tbl_key_group on tbl_user.user_id = tbl_key_group.owner_id
+            join tbl_key_group_key on tbl_key_group.key_group_id = tbl_key_group_key.key_group_id
+            join tbl_key on tbl_key_group_key.key_id = tbl_key.key_id
+            where user_id = $1"#,
+            vec![user_id.clone().into()],
+        ))
+        .all(db)
+        .await?;
+    Ok(values.iter().map(|f| f.into()).collect())
+}
diff --git a/api/src/crud/key_group.rs b/api/src/crud/key_group.rs
new file mode 100644
index 0000000..185799a
--- /dev/null
+++ b/api/src/crud/key_group.rs
@@ -0,0 +1,128 @@
+use entities::model::{tbl_key, tbl_key_group, tbl_key_group_key, tbl_user};
+use sea_orm::{
+    ActiveModelTrait, ColumnTrait, DatabaseConnection, EntityTrait, ModelTrait, QueryFilter, Set,
+};
+use serde::{Deserialize, Serialize};
+use utoipa::ToSchema;
+use uuid::Uuid;
+
+use crate::util::error::CrudError;
+
+use super::key::GetKey;
+
+#[derive(Debug, Serialize, Deserialize, ToSchema)]
+pub struct CreateKeyGroup {
+    name: String,
+    description: Option<String>,
+}
+
+#[derive(Debug, Serialize, Deserialize, ToSchema)]
+pub struct GetKeyGroup {
+    pub key_group_id: Uuid,
+    pub name: String,
+    pub description: Option<String>,
+}
+impl From<&tbl_key_group::Model> for GetKeyGroup {
+    fn from(model: &tbl_key_group::Model) -> Self {
+        let model = model.clone();
+        Self {
+            key_group_id: model.key_group_id,
+            name: model.name,
+            description: model.description,
+        }
+    }
+}
+pub async fn create_key_group(
+    key_goup: &CreateKeyGroup,
+    db: &DatabaseConnection,
+) -> Result<GetKeyGroup, CrudError> {
+    let model = tbl_key_group::ActiveModel {
+        name: Set(key_goup.name.to_string()),
+        description: Set(key_goup.description.clone()),
+        ..Default::default()
+    }
+    .insert(db)
+    .await?;
+    Ok((&model).into())
+}
+pub async fn update_key_group(
+    key_goup: &CreateKeyGroup,
+    key_group_id: &Uuid,
+    db: &DatabaseConnection,
+) -> Result<GetKeyGroup, CrudError> {
+    let model = tbl_key_group::Entity::find_by_id(key_group_id.clone())
+        .one(db)
+        .await?;
+    match model {
+        Some(model) => {
+            let mut model: tbl_key_group::ActiveModel = model.into();
+            model.description = Set(key_goup.description.clone());
+            model.name = Set(key_goup.name.clone());
+            let model = model.update(db).await?;
+            Ok((&model).into())
+        }
+        None => Err(CrudError::NotFound),
+    }
+}
+pub async fn add_key_to_key_group(
+    key_id: &Uuid,
+    key_group_id: &Uuid,
+    db: &DatabaseConnection,
+) -> Result<(), CrudError> {
+    tbl_key_group_key::ActiveModel {
+        key_group_id: Set(key_group_id.clone()),
+        key_id: Set(key_id.clone()),
+    }
+    .insert(db)
+    .await?;
+    Ok(())
+}
+pub async fn remove_key_from_key_group(
+    key_id: &Uuid,
+    key_group_id: &Uuid,
+    db: &DatabaseConnection,
+) -> Result<(), CrudError> {
+    let model = tbl_key_group_key::Entity::find()
+        .filter(tbl_key_group_key::Column::KeyGroupId.eq(key_group_id.clone()))
+        .filter(tbl_key_group_key::Column::KeyId.eq(key_id.clone()))
+        .one(db)
+        .await?;
+    match model {
+        Some(model) => {
+            model.delete(db).await?;
+            Ok(())
+        }
+        None => Err(CrudError::NotFound),
+    }
+}
+pub async fn get_all_key_group(db: &DatabaseConnection) -> Result<Vec<GetKeyGroup>, CrudError> {
+    let model = tbl_key_group::Entity::find().all(db).await?;
+    Ok(model.iter().map(|f| f.into()).collect())
+}
+pub async fn get_keys_of_key_group(
+    db: &DatabaseConnection,
+    key_group_id: &Uuid,
+) -> Result<Vec<GetKey>, CrudError> {
+    let model = tbl_key_group_key::Entity::find()
+        .filter(tbl_key_group_key::Column::KeyGroupId.eq(key_group_id.clone()))
+        .find_also_related(tbl_key::Entity)
+        .all(db)
+        .await?;
+    Ok(model
+        .iter()
+        .map(|f| (f.1.as_ref().expect("can not be null")).into())
+        .collect())
+}
+pub async fn get_key_group_of_user(
+    db: &DatabaseConnection,
+    user_id: &Uuid,
+) -> Result<Vec<GetKeyGroup>, CrudError> {
+    let model = tbl_user::Entity::find_by_id(user_id.clone())
+        .find_also_related(tbl_key_group::Entity)
+        .all(db)
+        .await?;
+    Ok(model
+        .iter()
+        .map(|f| (f.1.as_ref().expect("can not be null")).into())
+        .collect())
+}
diff --git a/api/src/crud/mod.rs b/api/src/crud/mod.rs
index cc60e43..7301f0b 100644
--- a/api/src/crud/mod.rs
+++ b/api/src/crud/mod.rs
@@ -1,3 +1,8 @@
+pub mod building;
+pub mod door;
+pub mod key;
+pub mod key_group;
 pub mod role;
+pub mod room;
 pub mod user;
 pub mod worker;
diff --git a/api/src/crud/room.rs b/api/src/crud/room.rs
new file mode 100644
index 0000000..88dbc84
--- /dev/null
+++ b/api/src/crud/room.rs
@@ -0,0 +1,42 @@
+use entities::model::tbl_room;
+use sea_orm::{DatabaseConnection, EntityTrait};
+use serde::{Deserialize, Serialize};
+use utoipa::ToSchema;
+use uuid::Uuid;
+
+use crate::util::error::CrudError;
+
+use super::building::GetBuilding;
+#[derive(Debug, Serialize, Deserialize, ToSchema)]
+pub struct GetRoom {
+    pub room_id: Uuid,
+    pub name: String,
+    pub floor: i32,
+    pub is_sensitive: Option<bool>,
+    pub building: Option<GetBuilding>,
+    pub building_id: Uuid,
+}
+impl From<&tbl_room::Model> for GetRoom {
+    fn from(room: &tbl_room::Model) -> Self {
+        Self {
+            name: room.name.clone(),
+            room_id: room.room_id,
+            floor: room.floor,
+            is_sensitive: room.is_sensitive,
+            building_id: room.building_id,
+            building: None,
+        }
+    }
+}
+pub async fn get_door_from_room_id(
+    room_id: &Uuid,
+    db: &DatabaseConnection,
+) -> Result<GetRoom, CrudError> {
+    let model = tbl_room::Entity::find_by_id(room_id.clone())
+        .one(db)
+        .await?;
+    match model {
+        Some(model) => Ok((&model).into()),
+        None => Err(CrudError::NotFound),
+    }
+}
diff --git a/api/src/main.rs b/api/src/main.rs
index e9f75a7..6311dca 100644
--- a/api/src/main.rs
+++ b/api/src/main.rs
@@ -5,7 +5,7 @@ pub mod util;
 use std::net::Ipv4Addr;
 
 use actix_cors::Cors;
-use actix_web::{web, App, HttpServer};
+use actix_web::{web::{self}, App, HttpServer};
 use utoipa_swagger_ui::SwaggerUi;
 
 use dotenv;
@@ -33,7 +33,17 @@ use utoipa::{OpenApi, openapi::{Server, Info}};
         api::worker::update_worker,
         api::worker::delete_worker,
         api::worker::get_worker,
-        api::worker::get_self,
+        api::worker::get_self_worker,
+        //key
+        api::key::get_self_key,
+        //key_group
+        api::key_group::add_key_into_key_group,
+        api::key_group::delete_key_from_key_group,
+        api::key_group::get_key_group,
+        api::key_group::get_keys_of_key_group,
+        api::key_group::get_self_key_group,
+        api::key_group::add_key_group,
+        api::key_group::upate_key_group,
     ),
     components(schemas(
         api::auth::Login,
@@ -43,6 +53,10 @@ use utoipa::{OpenApi, openapi::{Server, Info}};
         crud::user::GetUser,
         crud::worker::GetWorker,
         crud::worker::CreateWorker,
+        crud::key::GetKey,
+        crud::key_group::CreateKeyGroup,
+        crud::key_group::GetKeyGroup,
+        
     ))
 )]
 struct ApiDoc;
@@ -95,7 +109,18 @@ async fn main() -> anyhow::Result<()> {
                     .service(api::worker::update_worker)
                     .service(api::worker::delete_worker)
                     .service(api::worker::get_worker)
-                    .service(api::worker::get_self),
+                    .service(api::worker::get_self_worker)
+                    //key
+                    .service(api::key::get_self_key)
+                    //key_group
+                    .service(api::key_group::add_key_into_key_group)
+                    .service(api::key_group::delete_key_from_key_group)
+                    .service(api::key_group::get_key_group)
+                    .service(api::key_group::get_self_key_group)
+                    .service(api::key_group::get_keys_of_key_group)
+                    .service(api::key_group::add_key_group)
+                    .service(api::key_group::upate_key_group)
+                ,
             )
             .app_data(web::Data::new(db.clone()))
             .wrap(Cors::permissive())
diff --git a/entities/src/model/tbl_door.rs b/entities/src/model/tbl_door.rs
index 6a59513..92b678a 100644
--- a/entities/src/model/tbl_door.rs
+++ b/entities/src/model/tbl_door.rs
@@ -9,7 +9,7 @@ pub struct Model {
     #[sea_orm(primary_key, auto_increment = false)]
     pub door_id: Uuid,
     pub name: String,
-    pub room_id: Option<Uuid>,
+    pub room_id: Uuid,
 }
 
 #[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
diff --git a/entities/src/model/tbl_key_group.rs b/entities/src/model/tbl_key_group.rs
index 7d48386..8124e6d 100644
--- a/entities/src/model/tbl_key_group.rs
+++ b/entities/src/model/tbl_key_group.rs
@@ -8,6 +8,7 @@ use serde::{Deserialize, Serialize};
 pub struct Model {
     #[sea_orm(primary_key, auto_increment = false)]
     pub key_group_id: Uuid,
+    pub owner_id: Uuid,
     pub name: String,
     #[sea_orm(column_type = "Text", nullable)]
     pub description: Option<String>,
@@ -15,15 +16,23 @@ pub struct Model {
 
 #[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
 pub enum Relation {
-    #[sea_orm(has_many = "super::tbl_request::Entity")]
-    TblRequest,
+    #[sea_orm(
+        belongs_to = "super::tbl_user::Entity",
+        from = "Column::OwnerId",
+        to = "super::tbl_user::Column::UserId",
+        on_update = "NoAction",
+        on_delete = "NoAction"
+    )]
+    TblUser,
     #[sea_orm(has_many = "super::tbl_key_group_key::Entity")]
     TblKeyGroupKey,
+    #[sea_orm(has_many = "super::tbl_request::Entity")]
+    TblRequest,
 }
 
-impl Related<super::tbl_request::Entity> for Entity {
+impl Related<super::tbl_user::Entity> for Entity {
     fn to() -> RelationDef {
-        Relation::TblRequest.def()
+        Relation::TblUser.def()
     }
 }
 
@@ -33,4 +42,10 @@ impl Related<super::tbl_key_group_key::Entity> for Entity {
     }
 }
 
+impl Related<super::tbl_request::Entity> for Entity {
+    fn to() -> RelationDef {
+        Relation::TblRequest.def()
+    }
+}
+
 impl ActiveModelBehavior for ActiveModel {}
diff --git a/entities/src/model/tbl_user.rs b/entities/src/model/tbl_user.rs
index 59cea4f..af5664f 100644
--- a/entities/src/model/tbl_user.rs
+++ b/entities/src/model/tbl_user.rs
@@ -30,12 +30,14 @@ pub enum Relation {
     TblLeader,
     #[sea_orm(has_many = "super::tbl_admin::Entity")]
     TblAdmin,
-    #[sea_orm(has_many = "super::tbl_request::Entity")]
-    TblRequest,
+    #[sea_orm(has_many = "super::tbl_key_group::Entity")]
+    TblKeyGroup,
     #[sea_orm(has_many = "super::tbl_keycard::Entity")]
     TblKeycard,
     #[sea_orm(has_many = "super::tbl_request_comment::Entity")]
     TblRequestComment,
+    #[sea_orm(has_many = "super::tbl_request::Entity")]
+    TblRequest,
     #[sea_orm(has_many = "super::tbl_key_user_history::Entity")]
     TblKeyUserHistory,
     #[sea_orm(has_many = "super::tbl_worker::Entity")]
@@ -60,9 +62,9 @@ impl Related<super::tbl_admin::Entity> for Entity {
     }
 }
 
-impl Related<super::tbl_request::Entity> for Entity {
+impl Related<super::tbl_key_group::Entity> for Entity {
     fn to() -> RelationDef {
-        Relation::TblRequest.def()
+        Relation::TblKeyGroup.def()
     }
 }
 
@@ -78,6 +80,12 @@ impl Related<super::tbl_request_comment::Entity> for Entity {
     }
 }
 
+impl Related<super::tbl_request::Entity> for Entity {
+    fn to() -> RelationDef {
+        Relation::TblRequest.def()
+    }
+}
+
 impl Related<super::tbl_key_user_history::Entity> for Entity {
     fn to() -> RelationDef {
         Relation::TblKeyUserHistory.def()
diff --git a/migrations/20221020190412_setup.up.sql b/migrations/20221020190412_setup.up.sql
index 398c901..42d7443 100644
--- a/migrations/20221020190412_setup.up.sql
+++ b/migrations/20221020190412_setup.up.sql
@@ -65,7 +65,7 @@ create table if not exists tbl_admin(
 create table if not exists tbl_door(
     door_id uuid primary key DEFAULT uuid_generate_v4(),
     name varchar(255) not null,
-    room_id uuid,
+    room_id uuid not null,
     foreign key (room_id) references tbl_room(room_id)
 );
 create table if not exists tbl_key(
@@ -79,6 +79,8 @@ create table if not exists tbl_key(
 --group of keys
 create table if not exists tbl_key_group(
     key_group_id uuid primary key DEFAULT uuid_generate_v4(),
+    owner_id uuid not null,
+    foreign key (owner_id) references tbl_user(user_id),
     name varchar(255) not null,
     description text
 );
diff --git a/mock/src/main.rs b/mock/src/main.rs
index de0c2c3..b9542b1 100644
--- a/mock/src/main.rs
+++ b/mock/src/main.rs
@@ -117,7 +117,20 @@ async fn main() -> anyhow::Result<()> {
         }
         .insert(&db)
         .await?;
+
+        for _ in 0..rng.gen_range(1..4) {
+            let sentence: String = Sentence(0..5).fake_with_rng(&mut rng);
+            tbl_key_group::ActiveModel {
+                name: ActiveValue::Set(Industry(EN).fake_with_rng(&mut rng)),
+                description: ActiveValue::Set(Some(sentence)),
+                owner_id: ActiveValue::Set(user.user_id.clone()),
+                ..Default::default()
+            }
+            .insert(&db)
+            .await?;
+        }
     }
+    let key_groups = tbl_key_group::Entity::find().all(&db).await?;
     let keycards = tbl_keycard::Entity::find().all(&db).await?;
     let users_filtered: Vec<tbl_user::Model> = users
         .iter()
@@ -187,7 +200,7 @@ async fn main() -> anyhow::Result<()> {
     for room in &rooms {
         tbl_door::ActiveModel {
             name: ActiveValue::Set(BsNoun().fake_with_rng(&mut rng)),
-            room_id: ActiveValue::Set(Some(room.room_id)),
+            room_id: ActiveValue::Set(room.room_id),
             ..Default::default()
         }
         .insert(&db)
@@ -196,9 +209,7 @@ async fn main() -> anyhow::Result<()> {
     for _ in 0..200 {
         tbl_door::ActiveModel {
             name: ActiveValue::Set(BsNoun().fake_with_rng(&mut rng)),
-            room_id: ActiveValue::Set(Some(
-                rooms[rng.gen_range(0..rooms.len())].room_id.to_owned(),
-            )),
+            room_id: ActiveValue::Set(rooms[rng.gen_range(0..rooms.len())].room_id.to_owned()),
             ..Default::default()
         }
         .insert(&db)
@@ -217,17 +228,6 @@ async fn main() -> anyhow::Result<()> {
         .await?;
     }
     let keys = tbl_key::Entity::find().all(&db).await?;
-    for _ in 0..20 {
-        let sentence: String = Sentence(0..2).fake_with_rng(&mut rng);
-        tbl_key_group::ActiveModel {
-            name: ActiveValue::Set(Industry(EN).fake_with_rng(&mut rng)),
-            description: ActiveValue::Set(Some(sentence)),
-            ..Default::default()
-        }
-        .insert(&db)
-        .await?;
-    }
-    let key_groups = tbl_key_group::Entity::find().all(&db).await?;
 
     for group in &key_groups {
         for _ in 0..rng.gen_range(0..20) {
-- 
2.37.0 (Apple Git-136)

