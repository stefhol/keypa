From ca5a85d9988ba421ad1874b6b54a4fd5613ceaf0 Mon Sep 17 00:00:00 2001
From: stefhol <hoef.stef@pm.me>
Date: Sun, 6 Nov 2022 13:45:37 +0100
Subject: [PATCH 02/11] add more endpoints fix auth optimize db model

---
 .vscode/launch.json                      |   2 +-
 api/Cargo.toml                           |   1 -
 api/src/api/auth.rs                      |  78 ++++++-------
 api/src/api/mod.rs                       |   1 +
 api/src/api/user.rs                      | 106 +++++++++++-------
 api/src/api/worker.rs                    | 108 ++++++++++++++++++
 api/src/crud/user.rs                     |   8 +-
 api/src/crud/worker.rs                   | 136 +++++++++++++++--------
 api/src/main.rs                          |  13 ++-
 api/src/util/crypto.rs                   |  34 +-----
 api/src/util/error.rs                    |   9 +-
 api/src/util/middleware/mod.rs           |  52 +++++----
 entities/src/model/mod.rs                |   1 +
 entities/src/model/prelude.rs            |   1 +
 entities/src/model/tbl_admin.rs          |   1 -
 entities/src/model/tbl_key_group.rs      |  12 +-
 entities/src/model/tbl_leader.rs         |  17 ++-
 entities/src/model/tbl_user.rs           |  29 +++--
 entities/src/model/tbl_user_temp.rs      |  27 +++++
 entities/src/model/tbl_worker.rs         |   7 +-
 migrations/20221020190412_setup.down.sql |   3 +
 migrations/20221020190412_setup.up.sql   |  34 ++++--
 mock/src/main.rs                         |  24 ++--
 23 files changed, 460 insertions(+), 244 deletions(-)
 create mode 100644 api/src/api/worker.rs
 create mode 100644 entities/src/model/tbl_user_temp.rs

diff --git a/.vscode/launch.json b/.vscode/launch.json
index 1a57cc0..8f4a3e6 100644
--- a/.vscode/launch.json
+++ b/.vscode/launch.json
@@ -12,7 +12,7 @@
                 "args": [
                     "build",
                     "--bin",
-                    "api"
+                    "mock"
                 ]
             },
             "args": []
diff --git a/api/Cargo.toml b/api/Cargo.toml
index ab0a907..3e75312 100644
--- a/api/Cargo.toml
+++ b/api/Cargo.toml
@@ -17,7 +17,6 @@ anyhow = "1.0.65"
 dotenv = "0.15.0"
 tracing-subscriber = "0.3.16"
 tracing = "0.1.37"
-
 actix-web = "4.1.0"
 serde_urlencoded="0.7.1"
 actix-cors = "0.6.2"
diff --git a/api/src/api/auth.rs b/api/src/api/auth.rs
index 9d4e0e7..2d50c92 100644
--- a/api/src/api/auth.rs
+++ b/api/src/api/auth.rs
@@ -1,10 +1,13 @@
 use actix_web::{
     cookie::{time::Duration, Cookie},
-    web::{Data, Json},
-    HttpResponse,
+    web::Data,
 };
 use log::error;
-use paperclip::actix::{api_v2_operation, get, Apiv2Schema, HttpResponseWrapper, NoContent};
+use paperclip::actix::{
+    api_v2_operation, get,
+    web::{HttpResponse, Json},
+    Apiv2Schema, NoContent,
+};
 use sea_orm::DatabaseConnection;
 use serde::Deserialize;
 
@@ -12,7 +15,7 @@ use crate::{
     crud::{
         self,
         user::is_admin_by_user_id,
-        worker::{get_worker_by_user_id, is_leader_by_worker_id},
+        worker::{is_leader_by_user_id, is_worker_by_user_id},
     },
     util::{crypto::create_jwt, error::MyError, middleware::extractor::Authenticated},
 };
@@ -21,12 +24,13 @@ pub struct Login {
     email: String,
     password: String,
 }
-
+#[api_v2_operation]
 #[get("/login")]
 pub async fn login(
     db: Data<DatabaseConnection>,
     login: Json<Login>,
-) -> paperclip::actix::HttpResponseWrapper {
+    // ) -> actix_web::Result<HttpResponse, MyError> {
+) -> actix_web::Result<HttpResponse, MyError> {
     let model = crud::user::get_user_by_email(&db, &login.email).await;
     if let Ok(Some(user)) = model {
         let password =
@@ -40,21 +44,13 @@ pub async fn login(
             if let Err(err) = orion::pwhash::hash_password_verify(&user_password, &password) {
                 error!("{}", err);
             } else {
-                let worker = get_worker_by_user_id(&db, &user.user_id.to_string()).await;
-                let is_admin = is_admin_by_user_id(user.user_id, &db).await.map_err(|f| {
+                let user_id = &user.user_id.to_string();
+                let is_worker = is_worker_by_user_id(user_id, &db).await.unwrap_or(false);
+                let is_admin = is_admin_by_user_id(user_id, &db).await.map_err(|f| {
                     error!("{}", f);
                     f
                 });
-                let is_leader = match &worker {
-                    Ok(Some(worker)) => is_leader_by_worker_id(&worker.worker_id, &db)
-                        .await
-                        .map_err(|f| {
-                            error!("{}", f);
-                            f
-                        })
-                        .unwrap_or(false),
-                    _ => false,
-                };
+                let is_leader = is_leader_by_user_id(user_id, &db).await.unwrap_or(false);
                 let token = create_jwt(
                     &user.user_id.to_string(),
                     is_admin
@@ -63,39 +59,35 @@ pub async fn login(
                             f
                         })
                         .unwrap_or(false),
-                    worker
-                        .map_err(|f| {
-                            error!("{}", f);
-                            f
-                        })
-                        .unwrap_or(None)
-                        .is_some(),
+                    is_worker,
                     is_leader,
                 );
                 if let Ok(token) = token {
-                    return HttpResponseWrapper(
-                        HttpResponse::Ok()
-                            .cookie(
-                                Cookie::build("token", token)
-                                    .http_only(true)
-                                    .max_age(Duration::hours(8))
-                                    .finish(),
-                            )
-                            .finish(),
-                    );
+                    return Ok(HttpResponse::Ok()
+                        //same cookie
+                        //for ui state
+                        .cookie(
+                            Cookie::build("token", &token)
+                                .max_age(Duration::hours(8))
+                                .finish(),
+                        )
+                        //used in auth on server
+                        //securer through http only
+                        .cookie(
+                            Cookie::build("bearer", &token)
+                                .http_only(true)
+                                .max_age(Duration::hours(8))
+                                .finish(),
+                        )
+                        .finish());
                 }
             }
         }
     }
-    HttpResponseWrapper(HttpResponse::Unauthorized().finish())
+    Err(MyError::Unauthorized)
+    // HttpResponseWrapper(HttpResponse::Unauthorized().finish())
 }
-#[api_v2_operation(
-    summary = "My awesome handler",
-    description = "It creates a pretty JSON object",
-    /// A few other parameters are also supported
-    operation_id = "login",
-    tags("Api reference"),
-)]
+#[api_v2_operation]
 #[get("/register")]
 pub async fn register(
     _db: Data<DatabaseConnection>,
diff --git a/api/src/api/mod.rs b/api/src/api/mod.rs
index 7ec3d62..71489ea 100644
--- a/api/src/api/mod.rs
+++ b/api/src/api/mod.rs
@@ -1,3 +1,4 @@
 pub mod auth;
 pub mod key;
 pub mod user;
+pub mod worker;
diff --git a/api/src/api/user.rs b/api/src/api/user.rs
index 8a279a0..dc6f387 100644
--- a/api/src/api/user.rs
+++ b/api/src/api/user.rs
@@ -4,47 +4,79 @@ use crate::util::error::MyError;
 use crate::util::middleware::extractor::Authenticated;
 use crate::util::middleware::SecurityLevel;
 
-use actix_web::web::Data;
+use actix_web::web::{Data, Json, Path};
 use paperclip::actix::{api_v2_operation, delete, get, post, AcceptedJson};
 use paperclip::actix::{put, CreatedJson};
 use sea_orm::DatabaseConnection;
 
-#[api_v2_operation(
-    summary = "My awesome handler",
-    description = "It creates a pretty JSON object",
-    /// A few other parameters are also supported
-    operation_id = "get_user",
-    produces = "application/yaml, application/json",
-    tags("Api reference"),
-)]
+#[api_v2_operation(summary = "Get Users")]
 #[get("/users")]
 pub async fn get_users(
     db: Data<DatabaseConnection>,
     auth: Authenticated,
 ) -> actix_web::Result<AcceptedJson<Vec<GetUser>>, MyError> {
-    let users = crud::user::get_all_user(db.get_ref()).await;
     if auth.to_sercurity_level() < SecurityLevel::Worker {
         return Err(MyError::Unauthorized);
     }
+    let users = crud::user::get_all_user(db.get_ref()).await;
     return if let Ok(users) = users {
         Ok(AcceptedJson(users))
     } else {
         Err(MyError::Unauthorized)
     };
 }
-#[api_v2_operation(
-    summary = "Add new User",
-    description = "Adds new User to Database",
-    operation_id = "add_user",
-    consumes = "application/yaml, application/json",
-    produces = "application/yaml, application/json",
-    tags("Api reference")
-)]
+#[api_v2_operation(summary = "Get Single User")]
+#[get("/users/{user_id}")]
+pub async fn get_single_user(
+    db: Data<DatabaseConnection>,
+    user_id: Path<String>,
+    auth: Authenticated,
+) -> actix_web::Result<AcceptedJson<GetUser>, MyError> {
+    if auth.to_sercurity_level() < SecurityLevel::Worker {
+        return Err(MyError::Unauthorized);
+    }
+    let users = crud::user::get_single_user(db.get_ref(), &user_id).await;
+    return match users {
+        Ok(users) => match users {
+            Some(users) => Ok(AcceptedJson(users)),
+            _ => Err(MyError::NotFound),
+        },
+        _ => Err(MyError::Unauthorized),
+    };
+}
+#[api_v2_operation(summary = "Get self")]
+#[get("/self")]
+pub async fn get_self(
+    db: Data<DatabaseConnection>,
+    auth: Authenticated,
+) -> actix_web::Result<AcceptedJson<GetUser>, MyError> {
+    if auth.to_sercurity_level() < SecurityLevel::User {
+        return Err(MyError::Unauthorized);
+    }
+    match &auth.try_get_user_id() {
+        Some(user_id) => {
+            let users = crud::user::get_single_user(db.get_ref(), user_id).await;
+            match users {
+                Ok(users) => match users {
+                    Some(users) => Ok(AcceptedJson(users)),
+                    _ => Err(MyError::NotFound),
+                },
+                _ => Err(MyError::NotFound),
+            }
+        }
+        _ => Err(MyError::Unauthorized),
+    }
+}
+#[api_v2_operation(summary = "Add User")]
 #[post("/users")]
 pub async fn add_user(
-    user: actix_web::web::Json<CreateUser>,
+    user: Json<CreateUser>,
+    auth: Authenticated,
     db: Data<DatabaseConnection>,
 ) -> actix_web::Result<CreatedJson<GetUser>, MyError> {
+    if auth.to_sercurity_level() < SecurityLevel::Admin {
+        return Err(MyError::Unauthorized);
+    }
     let user = crud::user::create_user(db.get_ref(), user.0).await;
     return if let Ok(users) = user {
         Ok(CreatedJson(users))
@@ -52,39 +84,35 @@ pub async fn add_user(
         Err(MyError::Unauthorized)
     };
 }
-#[api_v2_operation(
-    summary = "Update User",
-    description = "Update User in Database",
-    operation_id = "update_user",
-    consumes = "application/yaml, application/json",
-    produces = "application/yaml, application/json",
-    tags("Api reference")
-)]
-#[put("/users/{id}")]
+#[api_v2_operation(summary = "Update User")]
+#[put("/users/{user_id}")]
 pub async fn update_user(
-    id: actix_web::web::Path<String>,
+    auth: Authenticated,
+    user_id: actix_web::web::Path<String>,
     user: actix_web::web::Json<ChangeUser>,
     db: Data<DatabaseConnection>,
 ) -> actix_web::Result<AcceptedJson<GetUser>, MyError> {
-    let user = crud::user::update_user(db.get_ref(), user.0, &id.into_inner()).await;
+    if auth.to_sercurity_level() < SecurityLevel::Admin || !auth.compare_user_id(user_id.as_str()) {
+        return Err(MyError::Unauthorized);
+    }
+    let user = crud::user::update_user(db.get_ref(), user.0, &user_id.into_inner()).await;
     return if let Ok(users) = user {
         Ok(AcceptedJson(users))
     } else {
         Err(MyError::Unauthorized)
     };
 }
-#[api_v2_operation(
-    summary = "Update User",
-    description = "Update User in Database",
-    operation_id = "update_user",
-    tags("Api reference")
-)]
-#[delete("/users/{id}")]
+#[api_v2_operation(summary = "Delete User")]
+#[delete("/users/{user_id}")]
 pub async fn delete_user(
-    id: actix_web::web::Path<String>,
+    user_id: actix_web::web::Path<String>,
     db: Data<DatabaseConnection>,
+    auth: Authenticated,
 ) -> actix_web::Result<paperclip::actix::NoContent, MyError> {
-    let user = crud::user::delete_user(db.get_ref(), &id.into_inner()).await;
+    if auth.to_sercurity_level() < SecurityLevel::Admin {
+        return Err(MyError::Unauthorized);
+    }
+    let user = crud::user::delete_user(db.get_ref(), &user_id.into_inner()).await;
     return if let Ok(_users) = user {
         Ok(paperclip::actix::NoContent)
     } else {
diff --git a/api/src/api/worker.rs b/api/src/api/worker.rs
new file mode 100644
index 0000000..cca8f43
--- /dev/null
+++ b/api/src/api/worker.rs
@@ -0,0 +1,108 @@
+use crate::crud;
+
+use crate::crud::worker::{CreateWorker, GetWorker};
+use crate::util::error::MyError;
+use crate::util::middleware::extractor::Authenticated;
+use crate::util::middleware::SecurityLevel;
+
+use actix_web::web::{Data, Path};
+use paperclip::actix::{api_v2_operation, delete, post, AcceptedJson, NoContent};
+use paperclip::actix::{get, put};
+use sea_orm::DatabaseConnection;
+
+#[api_v2_operation(summary = "Add Worker")]
+#[post("/users/{user_id}/worker")]
+pub async fn add_worker(
+    worker: actix_web::web::Json<CreateWorker>,
+    user_id: Path<String>,
+    auth: Authenticated,
+    db: Data<DatabaseConnection>,
+) -> actix_web::Result<paperclip::actix::NoContent, MyError> {
+    if auth.to_sercurity_level() < SecurityLevel::Admin {
+        return Err(MyError::Unauthorized);
+    }
+    let users = crud::worker::create_worker_from_user_id(user_id.as_str(), &worker, &db).await;
+    match users {
+        Ok(_) => Ok(NoContent),
+        _ => Err(MyError::NotFound),
+    }
+}
+#[api_v2_operation(summary = "Update Worker")]
+#[put("/users/{user_id}/worker")]
+pub async fn update_worker(
+    auth: Authenticated,
+    user_id: actix_web::web::Path<String>,
+    user: actix_web::web::Json<CreateWorker>,
+    db: Data<DatabaseConnection>,
+) -> actix_web::Result<NoContent, MyError> {
+    if auth.to_sercurity_level() < SecurityLevel::Admin {
+        return Err(MyError::Unauthorized);
+    }
+    let user = crud::worker::update_worker_with_user_id(
+        &user_id.into_inner(),
+        &user.into_inner(),
+        db.get_ref(),
+    )
+    .await;
+    match user {
+        Ok(_) => Ok(NoContent),
+        _ => Err(MyError::NotFound),
+    }
+}
+#[api_v2_operation(summary = "Delete Worker")]
+#[delete("/users/{user_id}/worker")]
+pub async fn delete_worker(
+    user_id: actix_web::web::Path<String>,
+    db: Data<DatabaseConnection>,
+    auth: Authenticated,
+) -> actix_web::Result<paperclip::actix::NoContent, MyError> {
+    if auth.to_sercurity_level() < SecurityLevel::Admin {
+        return Err(MyError::Unauthorized);
+    }
+    let user = crud::worker::delete_worker_with_user_id(user_id.as_str(), db.get_ref()).await;
+    match user {
+        Ok(_users) => Ok(NoContent),
+        _ => Err(MyError::NotFound),
+    }
+}
+#[api_v2_operation(
+    summary = "Get Worker",
+    description = "",
+    operation_id = "get_worker",
+    tags("Api reference")
+)]
+#[get("/users/{user_id}/worker")]
+pub async fn get_worker(
+    user_id: actix_web::web::Path<String>,
+    db: Data<DatabaseConnection>,
+    auth: Authenticated,
+) -> actix_web::Result<AcceptedJson<GetWorker>, MyError> {
+    if auth.to_sercurity_level() < SecurityLevel::Leader {
+        return Err(MyError::Unauthorized);
+    }
+    let worker = crud::worker::get_worker_by_user_id(db.get_ref(), user_id.as_str()).await;
+    match worker {
+        Ok(worker) => Ok(AcceptedJson(worker)),
+        _ => Err(MyError::NotFound),
+    }
+}
+#[api_v2_operation]
+#[get("/self/worker")]
+pub async fn get_self(
+    db: Data<DatabaseConnection>,
+    auth: Authenticated,
+) -> actix_web::Result<AcceptedJson<GetWorker>, MyError> {
+    if auth.to_sercurity_level() < SecurityLevel::Worker {
+        return Err(MyError::Unauthorized);
+    }
+    match auth.try_get_user_id() {
+        Some(user_id) => {
+            let worker = crud::worker::get_worker_by_user_id(db.get_ref(), &user_id).await;
+            match worker {
+                Ok(worker) => Ok(AcceptedJson(worker)),
+                _ => Err(MyError::NotFound),
+            }
+        }
+        _ => Err(MyError::Unauthorized),
+    }
+}
diff --git a/api/src/crud/user.rs b/api/src/crud/user.rs
index 8a4fa8d..095e78e 100644
--- a/api/src/crud/user.rs
+++ b/api/src/crud/user.rs
@@ -121,12 +121,10 @@ pub async fn create_user(db: &DatabaseConnection, user: CreateUser) -> Result<Ge
     return Ok(user);
 }
 pub async fn is_admin_by_user_id(
-    user_id: Uuid,
+    user_id: &str,
     db: &DatabaseConnection,
 ) -> Result<bool, CrudError> {
-    let admin = tbl_admin::Entity::find()
-        .filter(tbl_admin::Column::UserId.eq(user_id))
-        .one(db)
-        .await?;
+    let user_id = Uuid::parse_str(user_id)?;
+    let admin = tbl_admin::Entity::find_by_id(user_id).one(db).await?;
     return Ok(admin.is_some());
 }
diff --git a/api/src/crud/worker.rs b/api/src/crud/worker.rs
index 939b436..8bd2f84 100644
--- a/api/src/crud/worker.rs
+++ b/api/src/crud/worker.rs
@@ -1,15 +1,18 @@
 use entities::model::{tbl_leader, tbl_worker};
-use sea_orm::{ColumnTrait, DatabaseConnection, EntityTrait, QueryFilter, QuerySelect};
+use paperclip::actix::Apiv2Schema;
+use sea_orm::{ActiveModelTrait, ActiveValue, DatabaseConnection, EntityTrait, ModelTrait};
 use serde::{Deserialize, Serialize};
 use uuid::Uuid;
 
 use crate::util::error::CrudError;
 
-use super::{role::GetRole, user::get_single_user};
-#[derive(Serialize, Deserialize, Debug)]
-pub struct Worker {
+use super::{
+    role::GetRole,
+    user::{get_single_user, GetUser},
+};
+#[derive(Serialize, Deserialize, Debug, Apiv2Schema)]
+pub struct GetWorker {
     pub user_id: String,
-    pub worker_id: String,
     pub name: String,
     pub role: Option<GetRole>,
     pub email: String,
@@ -17,13 +20,11 @@ pub struct Worker {
     //only for internal use
     boss_id: Option<String>,
 
-    pub boss: Option<Boss>,
+    pub boss: Option<GetUser>,
 }
-#[derive(Serialize, Deserialize, Debug)]
+#[derive(Serialize, Deserialize, Debug, Apiv2Schema)]
 pub struct Boss {
     pub user_id: String,
-    pub worker_id: String,
-    pub leader_id: String,
     pub name: String,
     pub role: Option<GetRole>,
     pub email: String,
@@ -32,53 +33,45 @@ pub struct Boss {
 pub async fn get_worker_by_user_id(
     db: &DatabaseConnection,
     user_id: &str,
-) -> Result<Option<Worker>, CrudError> {
+) -> Result<GetWorker, CrudError> {
+    let user_id = Uuid::parse_str(user_id)?;
     let temp_worker = __get_worker_by_user_id(db, user_id).await?;
     if let Some(boss_id) = &temp_worker.boss_id {
         let boss_id = Uuid::parse_str(boss_id)?;
-        let boss_model = tbl_leader::Entity::find()
-            .filter(tbl_leader::Column::LeaderId.eq(boss_id))
-            .one(db)
-            .await?;
+        let boss_model = tbl_leader::Entity::find_by_id(boss_id).one(db).await?;
         let mut boss = None;
         if let Some(boss_model) = boss_model {
-            let user_boss_model = __get_worker_by_user_id(db, &boss_id.to_string()).await?;
+            let user_boss_model = __get_worker_by_user_id(db, boss_model.user_id.clone()).await?;
 
-            boss = Some(Boss {
+            boss = Some(GetUser {
                 user_id: user_boss_model.user_id.to_string(),
-                worker_id: boss_model.worker_id.to_string(),
-                leader_id: boss_model.leader_id.to_string(),
                 email: user_boss_model.email,
                 name: user_boss_model.name,
                 role: user_boss_model.role,
             });
         }
-        return Ok(Some(Worker {
+        return Ok(GetWorker {
             boss,
             ..temp_worker
-        }));
+        });
     }
-    Ok(None)
+    Ok(temp_worker)
 }
 /// Private function that gets a Worker without Boss struct
 async fn __get_worker_by_user_id(
     db: &DatabaseConnection,
-    user_id: &str,
-) -> Result<Worker, CrudError> {
-    let user_model = get_single_user(db, &user_id).await?;
-    let worker_model = tbl_worker::Entity::find()
-        .filter(tbl_worker::Column::UserId.eq(user_id))
-        .one(db)
-        .await?;
+    user_id: Uuid,
+) -> Result<GetWorker, CrudError> {
+    let user_model = get_single_user(db, &user_id.to_string()).await?;
+    let worker_model = tbl_worker::Entity::find_by_id(user_id).one(db).await?;
 
     if let (Some(user_model), Some(worker_model)) = (user_model, worker_model) {
-        let worker = Worker {
-            worker_id: worker_model.worker_id.to_string(),
+        let worker = GetWorker {
             email: user_model.email,
             role: user_model.role,
             name: user_model.name,
             user_id: user_model.user_id,
-            boss_id: worker_model.boss_id.map(|f| f.to_string()),
+            boss_id: worker_model.boss_user_id.map(|f| f.to_string()),
             boss: None,
         };
         return Ok(worker);
@@ -86,30 +79,75 @@ async fn __get_worker_by_user_id(
     Err(CrudError::NotFound)
 }
 
-pub async fn is_leader_by_worker_id(
-    worker_id: &str,
+pub async fn is_leader_by_user_id(
+    user_id: &str,
     db: &DatabaseConnection,
 ) -> Result<bool, CrudError> {
-    let worker_id = Uuid::parse_str(worker_id)?;
-    let leader = tbl_leader::Entity::find()
-        .filter(tbl_leader::Column::WorkerId.eq(worker_id))
-        .one(db)
-        .await?;
+    let worker_id = Uuid::parse_str(user_id)?;
+    let leader = tbl_leader::Entity::find_by_id(worker_id).one(db).await?;
     return Ok(leader.is_some());
 }
-pub async fn get_worker_id_by_user_id(
+pub async fn is_worker_by_user_id(
+    user_id: &str,
+    db: &DatabaseConnection,
+) -> Result<bool, CrudError> {
+    let user_id = Uuid::parse_str(user_id)?;
+    let worker = tbl_worker::Entity::find_by_id(user_id).one(db).await?;
+    return Ok(worker.is_some());
+}
+#[derive(Debug, Serialize, Deserialize, Apiv2Schema)]
+pub struct CreateWorker {
+    pub boss_user_id: Option<String>,
+}
+pub async fn create_worker_from_user_id(
     user_id: &str,
+    woker: &CreateWorker,
     db: &DatabaseConnection,
-) -> Result<Option<Uuid>, CrudError> {
+) -> Result<(), CrudError> {
     let user_id = Uuid::parse_str(user_id)?;
-    let worker = tbl_worker::Entity::find()
-        .filter(tbl_worker::Column::UserId.eq(user_id))
-        .select_only()
-        .column(tbl_worker::Column::WorkerId)
-        .one(db)
-        .await?;
-    if let Some(worker) = worker {
-        return Ok(Some(worker.worker_id));
+    let mut boss_id = None;
+    if let Some(id) = &woker.boss_user_id {
+        boss_id = Some(Uuid::parse_str(id)?);
+    }
+    tbl_worker::ActiveModel {
+        user_id: sea_orm::ActiveValue::Set(user_id),
+        boss_user_id: sea_orm::ActiveValue::Set(boss_id),
+        ..Default::default()
     }
-    Ok(None)
+    .insert(db)
+    .await?;
+    Ok(())
+}
+pub async fn update_worker_with_user_id(
+    user_id: &str,
+    woker: &CreateWorker,
+    db: &DatabaseConnection,
+) -> Result<(), CrudError> {
+    let user_id = Uuid::parse_str(user_id)?;
+    let worker = tbl_worker::Entity::find_by_id(user_id).one(db).await?;
+    return if let Some(worker) = worker {
+        let mut boss_id = None;
+        if let Some(id) = &woker.boss_user_id {
+            boss_id = Some(Uuid::parse_str(id)?);
+        }
+        let mut worker: tbl_worker::ActiveModel = worker.into();
+        worker.boss_user_id = ActiveValue::Set(boss_id);
+        worker.update(db).await?;
+        Ok(())
+    } else {
+        Err(CrudError::NotFound)
+    };
+}
+pub async fn delete_worker_with_user_id(
+    user_id: &str,
+    db: &DatabaseConnection,
+) -> Result<(), CrudError> {
+    let user_id = Uuid::parse_str(user_id)?;
+    let worker = tbl_worker::Entity::find_by_id(user_id).one(db).await?;
+    return if let Some(worker) = worker {
+        worker.delete(db).await?;
+        Ok(())
+    } else {
+        Err(CrudError::NotFound)
+    };
 }
diff --git a/api/src/main.rs b/api/src/main.rs
index 83f49b0..bf6642d 100644
--- a/api/src/main.rs
+++ b/api/src/main.rs
@@ -47,14 +47,23 @@ async fn main() -> anyhow::Result<()> {
             })
             .service(
                 web::scope("/api/v1")
-                    //user services
                     .wrap(util::middleware::Auth)
+                    //user services
                     .service(api::user::get_users)
                     .service(api::user::add_user)
                     .service(api::user::delete_user)
                     .service(api::user::update_user)
+                    .service(api::user::get_single_user)
+                    .service(api::user::get_self)
                     //login services
-                    .service(api::auth::login),
+                    .service(api::auth::login)
+                    .service(api::auth::register)
+                    //woker services
+                    .service(api::worker::add_worker)
+                    .service(api::worker::update_worker)
+                    .service(api::worker::delete_worker)
+                    .service(api::worker::get_worker)
+                    .service(api::worker::get_self),
             )
             .with_json_spec_at("/api/spec/v2/spec.json")
             .build()
diff --git a/api/src/util/crypto.rs b/api/src/util/crypto.rs
index 08dd3df..d9541c0 100644
--- a/api/src/util/crypto.rs
+++ b/api/src/util/crypto.rs
@@ -1,17 +1,13 @@
-use std::str::FromStr;
-
-use actix_web::cookie::Cookie;
-
 use chrono::{Duration, Utc};
 use jsonwebtoken::{decode, encode, Algorithm, DecodingKey, EncodingKey, Header, Validation};
-use sea_orm::{prelude::Uuid, DatabaseConnection};
-use serde::{Deserialize, Serialize};
+use paperclip::actix::Apiv2Schema;
 
-use crate::crud;
+use serde::{Deserialize, Serialize};
 
 use super::error::CrudError;
 const TOKEN_MAX_AGE: i64 = 8 * 60 * 60; //8Hours
-#[derive(Serialize, Deserialize, Clone, Debug)]
+#[derive(Serialize, Deserialize, Clone, Debug, Apiv2Schema)]
+#[openapi(empty)]
 pub struct Claims {
     pub sub: String,
     pub is_admin: bool,
@@ -55,25 +51,3 @@ pub fn authorize(token: &str) -> anyhow::Result<Claims> {
     )?;
     Ok(decoded.claims)
 }
-pub async fn is_admin(cookie: &Option<Cookie<'_>>, db: &DatabaseConnection) -> bool {
-    if let Some(cookie) = cookie {
-        let claim = self::authorize(cookie.value());
-        if let Ok(claim) = claim {
-            if let Ok(sub) = Uuid::from_str(&claim.sub) {
-                return crud::user::is_admin_by_user_id(sub, db)
-                    .await
-                    .unwrap_or(false);
-            }
-        }
-    }
-    false
-}
-pub fn is_self(cookie: Option<Cookie>, id: &str) -> bool {
-    if let Some(cookie) = cookie {
-        let claim = self::authorize(cookie.value());
-        if let Ok(claim) = claim {
-            return &claim.sub == id;
-        }
-    }
-    false
-}
diff --git a/api/src/util/error.rs b/api/src/util/error.rs
index 1a360e6..34fd112 100644
--- a/api/src/util/error.rs
+++ b/api/src/util/error.rs
@@ -19,18 +19,19 @@ pub enum CrudError {
     InvalidInput(String),
 }
 #[api_v2_errors(
-    code = 400,
     code = 401,
-    description = "Unauthorized: Can't read session from header",
-    code = 500
+    description = "Unauthorized: Can't access",
+    code = 404,
+    description = "Can't find ressource"
 )]
 #[derive(Debug, Error)]
 pub enum MyError {
     Unauthorized = 401,
+    NotFound = 400,
 }
 impl Display for MyError {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{}", self.to_string())
+        write!(f, "Unauthorized")
     }
 }
 impl ResponseError for MyError {
diff --git a/api/src/util/middleware/mod.rs b/api/src/util/middleware/mod.rs
index f2c4e2d..0760d2d 100644
--- a/api/src/util/middleware/mod.rs
+++ b/api/src/util/middleware/mod.rs
@@ -5,13 +5,13 @@ use std::{
 
 use actix_web::{
     body::MessageBody,
-    cookie::{time::Duration, Cookie},
     dev::{forward_ready, Service, ServiceRequest, ServiceResponse, Transform},
-    Error, HttpMessage, HttpResponse,
+    Error, HttpMessage,
 };
-use anyhow::anyhow;
+
 use futures::FutureExt;
 use futures_util::future::LocalBoxFuture;
+use paperclip::actix::Apiv2Schema;
 
 use crate::util::crypto;
 
@@ -32,7 +32,8 @@ impl Auth {
         Auth
     }
 }
-#[derive(Clone, Debug)]
+#[derive(Clone, Debug, Apiv2Schema)]
+#[openapi(empty)]
 pub enum AuthenticationResult {
     Authenticated(Claims),
     NotAuthenticated,
@@ -53,6 +54,19 @@ impl AuthenticationResult {
             SecurityLevel::External
         };
     }
+    pub fn try_get_user_id(&self) -> Option<String> {
+        match self {
+            AuthenticationResult::Authenticated(val) => Some(val.sub.to_string()),
+            _ => None,
+        }
+    }
+    ///Returns true if user_id in auth token and provided user_id is the same
+    pub fn compare_user_id(&self, user_id: &str) -> bool {
+        match self.try_get_user_id() {
+            Some(id) => &id == user_id,
+            None => false,
+        }
+    }
 }
 #[derive(Clone, PartialOrd, PartialEq)]
 pub enum SecurityLevel {
@@ -101,7 +115,7 @@ where
 
     fn call(&self, req: ServiceRequest) -> Self::Future {
         println!("Requested: {}", req.path());
-        if let Some(cookie) = req.cookie("token") {
+        if let Some(cookie) = req.cookie("bearer") {
             if let Ok(val) = crypto::authorize(cookie.value()) {
                 req.extensions_mut().insert::<AuthenticationInfo>(Rc::new(
                     AuthenticationResult::Authenticated(val),
@@ -117,14 +131,8 @@ where
         }
         let fut = self.service.call(req);
         async move {
-            let mut res = fut.await?;
-            return if let Ok(_) = add_token(res.response_mut()) {
-                Ok(res)
-            } else {
-                Err(actix_web::error::ErrorInternalServerError(anyhow!(
-                    "Error in Authentication"
-                )))
-            };
+            let res = fut.await?;
+            Ok(res)
         }
         .boxed_local()
     }
@@ -132,12 +140,12 @@ where
     forward_ready!(service);
 }
 pub mod extractor;
-fn add_token<B>(res: &mut HttpResponse<B>) -> anyhow::Result<()> {
-    res.add_cookie(
-        &Cookie::build("token", "value")
-            .max_age(Duration::hours(8))
-            .http_only(true)
-            .finish(),
-    )?;
-    Ok(())
-}
+// fn add_token<B>(res: &mut HttpResponse<B>) -> anyhow::Result<()> {
+//     res.add_cookie(
+//         &Cookie::build("token", "value")
+//             .max_age(Duration::hours(8))
+//             .http_only(true)
+//             .finish(),
+//     )?;
+//     Ok(())
+// }
diff --git a/entities/src/model/mod.rs b/entities/src/model/mod.rs
index e86c627..f688083 100644
--- a/entities/src/model/mod.rs
+++ b/entities/src/model/mod.rs
@@ -17,4 +17,5 @@ pub mod tbl_request_comment;
 pub mod tbl_role;
 pub mod tbl_room;
 pub mod tbl_user;
+pub mod tbl_user_temp;
 pub mod tbl_worker;
diff --git a/entities/src/model/prelude.rs b/entities/src/model/prelude.rs
index 023e140..c736b61 100644
--- a/entities/src/model/prelude.rs
+++ b/entities/src/model/prelude.rs
@@ -15,4 +15,5 @@ pub use super::tbl_request_comment::Entity as TblRequestComment;
 pub use super::tbl_role::Entity as TblRole;
 pub use super::tbl_room::Entity as TblRoom;
 pub use super::tbl_user::Entity as TblUser;
+pub use super::tbl_user_temp::Entity as TblUserTemp;
 pub use super::tbl_worker::Entity as TblWorker;
diff --git a/entities/src/model/tbl_admin.rs b/entities/src/model/tbl_admin.rs
index d3d0a45..8f4aef6 100644
--- a/entities/src/model/tbl_admin.rs
+++ b/entities/src/model/tbl_admin.rs
@@ -7,7 +7,6 @@ use serde::{Deserialize, Serialize};
 #[sea_orm(table_name = "tbl_admin")]
 pub struct Model {
     #[sea_orm(primary_key, auto_increment = false)]
-    pub admin_id: Uuid,
     pub user_id: Uuid,
 }
 
diff --git a/entities/src/model/tbl_key_group.rs b/entities/src/model/tbl_key_group.rs
index db35201..7d48386 100644
--- a/entities/src/model/tbl_key_group.rs
+++ b/entities/src/model/tbl_key_group.rs
@@ -15,21 +15,21 @@ pub struct Model {
 
 #[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
 pub enum Relation {
-    #[sea_orm(has_many = "super::tbl_key_group_key::Entity")]
-    TblKeyGroupKey,
     #[sea_orm(has_many = "super::tbl_request::Entity")]
     TblRequest,
+    #[sea_orm(has_many = "super::tbl_key_group_key::Entity")]
+    TblKeyGroupKey,
 }
 
-impl Related<super::tbl_key_group_key::Entity> for Entity {
+impl Related<super::tbl_request::Entity> for Entity {
     fn to() -> RelationDef {
-        Relation::TblKeyGroupKey.def()
+        Relation::TblRequest.def()
     }
 }
 
-impl Related<super::tbl_request::Entity> for Entity {
+impl Related<super::tbl_key_group_key::Entity> for Entity {
     fn to() -> RelationDef {
-        Relation::TblRequest.def()
+        Relation::TblKeyGroupKey.def()
     }
 }
 
diff --git a/entities/src/model/tbl_leader.rs b/entities/src/model/tbl_leader.rs
index 788525a..7a59762 100644
--- a/entities/src/model/tbl_leader.rs
+++ b/entities/src/model/tbl_leader.rs
@@ -7,22 +7,29 @@ use serde::{Deserialize, Serialize};
 #[sea_orm(table_name = "tbl_leader")]
 pub struct Model {
     #[sea_orm(primary_key, auto_increment = false)]
-    pub leader_id: Uuid,
-    pub worker_id: Uuid,
+    pub user_id: Uuid,
 }
 
 #[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
 pub enum Relation {
     #[sea_orm(
-        belongs_to = "super::tbl_worker::Entity",
-        from = "Column::WorkerId",
-        to = "super::tbl_worker::Column::WorkerId",
+        belongs_to = "super::tbl_user::Entity",
+        from = "Column::UserId",
+        to = "super::tbl_user::Column::UserId",
         on_update = "NoAction",
         on_delete = "NoAction"
     )]
+    TblUser,
+    #[sea_orm(has_many = "super::tbl_worker::Entity")]
     TblWorker,
 }
 
+impl Related<super::tbl_user::Entity> for Entity {
+    fn to() -> RelationDef {
+        Relation::TblUser.def()
+    }
+}
+
 impl Related<super::tbl_worker::Entity> for Entity {
     fn to() -> RelationDef {
         Relation::TblWorker.def()
diff --git a/entities/src/model/tbl_user.rs b/entities/src/model/tbl_user.rs
index 9e8d79c..59cea4f 100644
--- a/entities/src/model/tbl_user.rs
+++ b/entities/src/model/tbl_user.rs
@@ -12,6 +12,7 @@ pub struct Model {
     pub role_id: Option<Uuid>,
     pub is_active: bool,
     pub email: String,
+    pub picture_url: Option<String>,
     pub password: String,
 }
 
@@ -25,18 +26,20 @@ pub enum Relation {
         on_delete = "NoAction"
     )]
     TblRole,
-    #[sea_orm(has_many = "super::tbl_worker::Entity")]
-    TblWorker,
+    #[sea_orm(has_many = "super::tbl_leader::Entity")]
+    TblLeader,
     #[sea_orm(has_many = "super::tbl_admin::Entity")]
     TblAdmin,
-    #[sea_orm(has_many = "super::tbl_keycard::Entity")]
-    TblKeycard,
     #[sea_orm(has_many = "super::tbl_request::Entity")]
     TblRequest,
+    #[sea_orm(has_many = "super::tbl_keycard::Entity")]
+    TblKeycard,
     #[sea_orm(has_many = "super::tbl_request_comment::Entity")]
     TblRequestComment,
     #[sea_orm(has_many = "super::tbl_key_user_history::Entity")]
     TblKeyUserHistory,
+    #[sea_orm(has_many = "super::tbl_worker::Entity")]
+    TblWorker,
 }
 
 impl Related<super::tbl_role::Entity> for Entity {
@@ -45,9 +48,9 @@ impl Related<super::tbl_role::Entity> for Entity {
     }
 }
 
-impl Related<super::tbl_worker::Entity> for Entity {
+impl Related<super::tbl_leader::Entity> for Entity {
     fn to() -> RelationDef {
-        Relation::TblWorker.def()
+        Relation::TblLeader.def()
     }
 }
 
@@ -57,15 +60,15 @@ impl Related<super::tbl_admin::Entity> for Entity {
     }
 }
 
-impl Related<super::tbl_keycard::Entity> for Entity {
+impl Related<super::tbl_request::Entity> for Entity {
     fn to() -> RelationDef {
-        Relation::TblKeycard.def()
+        Relation::TblRequest.def()
     }
 }
 
-impl Related<super::tbl_request::Entity> for Entity {
+impl Related<super::tbl_keycard::Entity> for Entity {
     fn to() -> RelationDef {
-        Relation::TblRequest.def()
+        Relation::TblKeycard.def()
     }
 }
 
@@ -81,4 +84,10 @@ impl Related<super::tbl_key_user_history::Entity> for Entity {
     }
 }
 
+impl Related<super::tbl_worker::Entity> for Entity {
+    fn to() -> RelationDef {
+        Relation::TblWorker.def()
+    }
+}
+
 impl ActiveModelBehavior for ActiveModel {}
diff --git a/entities/src/model/tbl_user_temp.rs b/entities/src/model/tbl_user_temp.rs
new file mode 100644
index 0000000..9931edb
--- /dev/null
+++ b/entities/src/model/tbl_user_temp.rs
@@ -0,0 +1,27 @@
+//! SeaORM Entity. Generated by sea-orm-codegen 0.9.2
+
+use sea_orm::entity::prelude::*;
+use serde::{Deserialize, Serialize};
+
+#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize)]
+#[sea_orm(table_name = "tbl_user_temp")]
+pub struct Model {
+    #[sea_orm(primary_key, auto_increment = false)]
+    pub temp_id: Uuid,
+    pub created_at: DateTime,
+    pub name: Option<String>,
+    pub email: Option<String>,
+    #[sea_orm(column_type = "Text", nullable)]
+    pub description: Option<String>,
+}
+
+#[derive(Copy, Clone, Debug, EnumIter)]
+pub enum Relation {}
+
+impl RelationTrait for Relation {
+    fn def(&self) -> RelationDef {
+        panic!("No RelationDef")
+    }
+}
+
+impl ActiveModelBehavior for ActiveModel {}
diff --git a/entities/src/model/tbl_worker.rs b/entities/src/model/tbl_worker.rs
index e6088f3..5010ef5 100644
--- a/entities/src/model/tbl_worker.rs
+++ b/entities/src/model/tbl_worker.rs
@@ -7,17 +7,16 @@ use serde::{Deserialize, Serialize};
 #[sea_orm(table_name = "tbl_worker")]
 pub struct Model {
     #[sea_orm(primary_key, auto_increment = false)]
-    pub worker_id: Uuid,
     pub user_id: Uuid,
-    pub boss_id: Option<Uuid>,
+    pub boss_user_id: Option<Uuid>,
 }
 
 #[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
 pub enum Relation {
     #[sea_orm(
         belongs_to = "super::tbl_leader::Entity",
-        from = "Column::BossId",
-        to = "super::tbl_leader::Column::LeaderId",
+        from = "Column::BossUserId",
+        to = "super::tbl_leader::Column::UserId",
         on_update = "NoAction",
         on_delete = "NoAction"
     )]
diff --git a/migrations/20221020190412_setup.down.sql b/migrations/20221020190412_setup.down.sql
index fa5567b..9c40ec5 100644
--- a/migrations/20221020190412_setup.down.sql
+++ b/migrations/20221020190412_setup.down.sql
@@ -25,3 +25,6 @@ drop table if exists tbl_building;
 drop table if exists tbl_worker;
 drop table if exists tbl_user;
 drop table if exists tbl_role;
+drop trigger if exists tbl_user_temp_delete_row_trigger on tbl_user_temp;
+drop function if exists tbl_user_temp_delete_row_function;
+drop table if exists tbl_user_temp;
diff --git a/migrations/20221020190412_setup.up.sql b/migrations/20221020190412_setup.up.sql
index 4ebfad2..398c901 100644
--- a/migrations/20221020190412_setup.up.sql
+++ b/migrations/20221020190412_setup.up.sql
@@ -1,4 +1,23 @@
 create extension if not exists "uuid-ossp";
+
+create table if not exists tbl_user_temp(
+    temp_id uuid primary key default uuid_generate_v4(),
+    created_at timestamp without time zone not null default timezone('utc', now()),
+    name varchar(255),
+    email varchar(255),
+    description text
+                    );
+CREATE FUNCTION tbl_user_temp_delete_row_function() RETURNS trigger
+    LANGUAGE plpgsql
+    AS $$
+BEGIN
+  DELETE FROM tbl_user_temp WHERE tbl_user_temp.created_at < timezone('utc', now()) - INTERVAL '1 week';
+  RETURN NEW;
+END;
+$$;
+CREATE TRIGGER tbl_user_temp_delete_row_trigger
+    AFTER INSERT ON tbl_user_temp
+    EXECUTE PROCEDURE tbl_user_temp_delete_row_function();
 create table if not exists tbl_role(
     role_id uuid primary key DEFAULT uuid_generate_v4(),
     name varchar(255) not null,
@@ -28,22 +47,19 @@ create table if not exists tbl_room(
     foreign key(building_id) references tbl_building(building_id)
 );
 create table if not exists tbl_worker(
-    worker_id uuid primary key DEFAULT uuid_generate_v4(),
-    user_id uuid not null,
+    user_id uuid primary key,
     foreign key(user_id) REFERENCES tbl_user(user_id),
     --worker has a leader foreign key gets added later
-    boss_id uuid
+    boss_user_id uuid
 );
 create table if not exists tbl_leader(
-    leader_id uuid primary key DEFAULT uuid_generate_v4(),
     --leader is a worker and a worker has a user
-    worker_id uuid not null,
-    foreign key (worker_id) references tbl_worker(worker_id)
+    user_id uuid primary key ,
+    foreign key (user_id) references tbl_user(user_id)
 );
-alter table tbl_worker add constraint fk_worker_leader foreign key(boss_id) references tbl_leader(leader_id);
+alter table tbl_worker add constraint fk_worker_leader foreign key(boss_user_id) references tbl_leader(user_id);
 create table if not exists tbl_admin(
-    admin_id uuid primary key DEFAULT uuid_generate_v4(),
-    user_id uuid not null,
+    user_id uuid primary key,
     foreign key (user_id) references tbl_user(user_id)
 );
 create table if not exists tbl_door(
diff --git a/mock/src/main.rs b/mock/src/main.rs
index 457b49d..bf51905 100644
--- a/mock/src/main.rs
+++ b/mock/src/main.rs
@@ -119,17 +119,19 @@ async fn main() -> anyhow::Result<()> {
         .await?;
     }
     let keycards = tbl_keycard::Entity::find().all(&db).await?;
-    //insert workers
-    for worker in users.iter().filter(|f| {
+    let users_filtered:Vec<tbl_user::Model>= users.iter().filter(|f| {
         f.role_id.unwrap()
             == roles
                 .iter()
                 .find(|f| f.name == "Angestellter")
                 .unwrap()
                 .role_id
-    }) {
+    }).map(|f|f.to_owned()).collect::<>();
+    //insert workers
+    for user in users_filtered {
+        println!("{:#?}",user);
         tbl_worker::ActiveModel {
-            user_id: ActiveValue::Set(worker.user_id.to_owned()),
+            user_id: ActiveValue::Set(user.user_id.to_owned()),
             ..Default::default()
         }
         .insert(&db)
@@ -137,14 +139,9 @@ async fn main() -> anyhow::Result<()> {
     }
     let workers = tbl_worker::Entity::find().all(&db).await?;
     //select leaders out of workers
-    for _ in 0..3 {
+    for idx in 0..3 {
         tbl_leader::ActiveModel {
-            worker_id: ActiveValue::Set(
-                workers
-                    .get(rng.gen_range(0..workers.len()))
-                    .unwrap()
-                    .worker_id,
-            ),
+            user_id: ActiveValue::Set(workers.get(idx).unwrap().user_id),
             ..Default::default()
         }
         .insert(&db)
@@ -152,12 +149,13 @@ async fn main() -> anyhow::Result<()> {
     }
     let leaders = tbl_leader::Entity::find().all(&db).await?;
     for worker in &workers {
-        if leaders.iter().any(|f| f.worker_id == worker.worker_id) {
+        if leaders.iter().any(|f| f.user_id == worker.user_id) {
             //worker is leader skip
             continue;
         }
         let mut worker: tbl_worker::ActiveModel = worker.clone().into();
-        worker.boss_id = ActiveValue::Set(Some(leaders[rng.gen_range(0..leaders.len())].leader_id));
+        worker.boss_user_id =
+            ActiveValue::Set(Some(leaders[rng.gen_range(0..leaders.len())].user_id));
         worker.update(&db).await?;
     }
     for _ in 0..4 {
-- 
2.37.0 (Apple Git-136)

